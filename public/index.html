<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MRZ Bot</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg: #0a0a0f;
            --bg-secondary: #12121a;
            --bg-tertiary: #1a1a24;
            --bg-hover: #22222e;
            --border: #2a2a3a;
            --text: #e4e4e7;
            --text-muted: #71717a;
            --accent: #8b5cf6;
            --accent-hover: #a78bfa;
            --success: #22c55e;
            --error: #ef4444;
            --warning: #f59e0b;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            display: flex;
        }

        /* Sidebar */
        .sidebar {
            width: 70px;
            background: var(--bg-secondary);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 16px 0;
            position: fixed;
            height: 100vh;
            z-index: 100;
        }
        .logo { width: 40px; height: 40px; margin-bottom: 24px; }
        .logo svg { width: 100%; height: 100%; }
        .nav { display: flex; flex-direction: column; gap: 4px; width: 100%; padding: 0 8px; }
        .nav-item {
            display: flex; flex-direction: column; align-items: center;
            padding: 12px 4px; border-radius: 8px; cursor: pointer;
            color: var(--text-muted); transition: all 0.2s; text-decoration: none;
        }
        .nav-item:hover { background: var(--bg-hover); color: var(--text); }
        .nav-item.active { background: var(--bg-tertiary); color: var(--accent); }
        .nav-item svg { width: 20px; height: 20px; margin-bottom: 4px; }
        .nav-item span { font-size: 10px; font-weight: 500; }

        /* Main */
        .main { flex: 1; margin-left: 70px; min-height: 100vh; }

        /* Header */
        .header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 12px 24px; border-bottom: 1px solid var(--border);
            background: var(--bg-secondary); position: sticky; top: 0; z-index: 50;
        }
        .header-title { font-size: 1.1rem; font-weight: 600; }
        .header-right { display: flex; gap: 12px; align-items: center; }
        .network-select {
            background: var(--bg-tertiary); border: 1px solid var(--border);
            color: var(--text); padding: 8px 12px; border-radius: 8px; font-size: 0.8rem;
        }
        .connect-btn {
            background: var(--accent); color: white; border: none;
            padding: 8px 16px; border-radius: 8px; font-size: 0.8rem; font-weight: 500; cursor: pointer;
        }
        .wallet-badge {
            background: var(--bg-tertiary); border: 1px solid var(--border);
            padding: 8px 12px; border-radius: 8px; font-size: 0.75rem; font-family: monospace;
            display: flex; align-items: center; gap: 8px;
        }
        .wallet-badge .dot { width: 8px; height: 8px; background: var(--success); border-radius: 50%; }

        /* Page */
        .page { display: none; padding: 20px; }
        .page.active { display: block; }

        /* Task Groups */
        .task-groups { display: flex; gap: 12px; margin-bottom: 20px; flex-wrap: wrap; align-items: flex-start; }
        .task-group {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 10px; padding: 14px 18px; cursor: pointer; min-width: 140px;
            position: relative;
        }
        .task-group.active { border-color: var(--accent); }
        .task-group .name { font-size: 0.85rem; font-weight: 500; display: flex; align-items: center; gap: 6px; margin-bottom: 6px; }
        .task-group .name .icon { color: var(--accent); }
        .task-group .stats { display: flex; gap: 12px; font-size: 0.7rem; color: var(--text-muted); }
        .task-group .stats span { display: flex; align-items: center; gap: 3px; }
        .task-group .close { position: absolute; top: 8px; right: 8px; background: none; border: none; color: var(--text-muted); cursor: pointer; font-size: 14px; }
        .task-group .close:hover { color: var(--error); }
        .task-group-new {
            background: var(--bg-tertiary); border: 1px dashed var(--border);
            border-radius: 10px; padding: 20px 24px; cursor: pointer;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: var(--text-muted); min-width: 120px;
        }
        .task-group-new:hover { border-color: var(--accent); color: var(--text); }
        .task-group-new svg { width: 24px; height: 24px; margin-bottom: 6px; }

        /* Cards */
        .card { background: var(--bg-secondary); border: 1px solid var(--border); border-radius: 10px; overflow: hidden; }
        .card-header { display: flex; justify-content: space-between; align-items: center; padding: 14px 18px; border-bottom: 1px solid var(--border); }
        .card-title { font-size: 0.85rem; font-weight: 600; }
        .card-body { padding: 18px; }

        /* Form */
        .form-row { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 12px; margin-bottom: 14px; }
        .form-group { margin-bottom: 0; }
        .form-group label { display: block; font-size: 0.7rem; color: var(--text-muted); margin-bottom: 5px; text-transform: uppercase; }
        .form-group.required label::after { content: '*'; color: var(--error); margin-left: 2px; }
        input, select, textarea {
            width: 100%; background: var(--bg-tertiary); border: 1px solid var(--border);
            color: var(--text); padding: 10px 12px; border-radius: 6px; font-size: 0.8rem;
        }
        input:focus, select:focus { outline: none; border-color: var(--accent); }
        input::placeholder { color: var(--text-muted); }
        .input-suffix { position: relative; }
        .input-suffix input { padding-right: 40px; }
        .input-suffix span { position: absolute; right: 10px; top: 50%; transform: translateY(-50%); color: var(--text-muted); font-size: 0.75rem; }

        /* Buttons */
        .btn {
            padding: 8px 14px; border-radius: 6px; font-size: 0.8rem; font-weight: 500;
            cursor: pointer; border: 1px solid var(--border); background: var(--bg-tertiary);
            color: var(--text); display: inline-flex; align-items: center; gap: 6px;
        }
        .btn:hover { background: var(--bg-hover); }
        .btn-primary { background: var(--accent); border-color: var(--accent); color: white; }
        .btn-primary:hover { background: var(--accent-hover); }
        .btn-danger { background: rgba(239,68,68,0.2); border-color: var(--error); color: var(--error); }
        .btn-sm { padding: 5px 10px; font-size: 0.75rem; }
        .gas-preset.active { outline: 2px solid var(--accent); outline-offset: 1px; }
        .btn-group { display: flex; gap: 8px; }

        /* Toggle */
        .toggle { display: flex; align-items: center; gap: 8px; cursor: pointer; }
        .toggle-track {
            width: 36px; height: 20px; background: var(--bg-hover); border-radius: 10px;
            position: relative; transition: background 0.2s;
        }
        .toggle-track::after {
            content: ''; position: absolute; width: 16px; height: 16px;
            background: var(--text-muted); border-radius: 50%; top: 2px; left: 2px; transition: all 0.2s;
        }
        .toggle.active .toggle-track { background: var(--success); }
        .toggle.active .toggle-track::after { left: 18px; background: white; }
        .toggle-label { font-size: 0.8rem; }

        /* Table */
        table { width: 100%; border-collapse: collapse; }
        th, td { text-align: left; padding: 12px 14px; border-bottom: 1px solid var(--border); font-size: 0.8rem; }
        th { color: var(--text-muted); font-weight: 500; font-size: 0.7rem; text-transform: uppercase; }
        tr:hover td { background: var(--bg-hover); }
        .table-link { color: var(--accent); text-decoration: none; }

        /* Wallet Groups */
        .wallet-groups { display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap; }
        .wallet-group-chip {
            background: var(--bg-tertiary); border: 1px solid var(--border);
            border-radius: 6px; padding: 8px 14px; cursor: pointer; font-size: 0.8rem;
            display: flex; align-items: center; gap: 6px;
        }
        .wallet-group-chip.active { border-color: var(--accent); background: rgba(139,92,246,0.1); }
        .wallet-group-chip .count { color: var(--text-muted); font-size: 0.7rem; }

        /* Modal */
        .modal-overlay {
            position: fixed; inset: 0; background: rgba(0,0,0,0.8);
            display: none; align-items: center; justify-content: center; z-index: 1000;
        }
        .modal-overlay.show { display: flex; }
        .modal {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 10px; width: 90%; max-width: 500px; max-height: 85vh; overflow: auto;
        }
        .modal-header {
            display: flex; justify-content: space-between; align-items: center;
            padding: 16px 20px; border-bottom: 1px solid var(--border);
        }
        .modal-header h3 { font-size: 0.95rem; }
        .modal-close { background: none; border: none; color: var(--text-muted); font-size: 1.25rem; cursor: pointer; }
        .modal-body { padding: 20px; }
        .modal-footer { padding: 16px 20px; border-top: 1px solid var(--border); display: flex; justify-content: flex-end; gap: 8px; }

        /* Notification */
        .notification {
            position: fixed; top: 70px; right: 20px;
            padding: 12px 18px; border-radius: 8px;
            display: none; align-items: center; gap: 10px; z-index: 1000; font-size: 0.85rem;
        }
        .notification.show { display: flex; }
        .notification.success { background: rgba(34,197,94,0.15); border: 1px solid var(--success); color: var(--success); }
        .notification.error { background: rgba(239,68,68,0.15); border: 1px solid var(--error); color: var(--error); }
        .notification.pending { background: rgba(245,158,11,0.15); border: 1px solid var(--warning); color: var(--warning); }

        /* Stats */
        .stats-row { display: flex; gap: 16px; margin-bottom: 20px; flex-wrap: wrap; }
        .stat-card {
            background: var(--bg-secondary); border: 1px solid var(--border);
            border-radius: 10px; padding: 16px 20px; display: flex; align-items: center; gap: 12px;
        }
        .stat-card .icon { width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center; font-size: 1.1rem; }
        .stat-card .icon.green { background: rgba(34,197,94,0.2); color: var(--success); }
        .stat-card .icon.red { background: rgba(239,68,68,0.2); color: var(--error); }
        .stat-card .icon.purple { background: rgba(139,92,246,0.2); color: var(--accent); }
        .stat-card .info .label { font-size: 0.7rem; color: var(--text-muted); }
        .stat-card .info .value { font-size: 1.25rem; font-weight: 700; }

        /* Contract Info */
        .contract-info {
            background: var(--bg-tertiary); border-radius: 8px; padding: 12px 16px;
            display: flex; align-items: center; gap: 12px; margin-bottom: 16px;
        }
        .contract-info .token-icon { width: 36px; height: 36px; background: var(--accent); border-radius: 8px; display: flex; align-items: center; justify-content: center; font-weight: bold; }
        .contract-info .token-name { font-weight: 600; font-size: 0.9rem; }
        .contract-info .token-address { font-size: 0.75rem; color: var(--text-muted); font-family: monospace; }

        /* Task List */
        .task-list { display: flex; flex-direction: column; gap: 8px; }
        .task-item {
            background: var(--bg-tertiary); border: 1px solid var(--border);
            border-radius: 8px; padding: 12px 16px; display: flex; align-items: center; justify-content: space-between;
        }
        .task-item .info { display: flex; align-items: center; gap: 12px; }
        .task-item .status { width: 8px; height: 8px; border-radius: 50%; }
        .task-item .status.pending { background: var(--warning); }
        .task-item .status.running { background: var(--accent); animation: pulse 1s infinite; }
        .task-item .status.success { background: var(--success); }
        .task-item .status.failed { background: var(--error); }
        .task-item .status.stopped { background: var(--text-muted); }
        @keyframes pulse { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        /* Helpers */
        .mb-16 { margin-bottom: 16px; }
        .mb-20 { margin-bottom: 20px; }
        .flex-between { display: flex; justify-content: space-between; align-items: center; }
        .text-muted { color: var(--text-muted); }
        .text-success { color: var(--success); }
        .text-error { color: var(--error); }
        .mono { font-family: monospace; }
        .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }

        /* Detecting Animation */
        .detecting { display: flex; align-items: center; gap: 8px; color: var(--text-muted); font-size: 0.8rem; }
        .detecting .spinner { width: 14px; height: 14px; border: 2px solid var(--border); border-top-color: var(--accent); border-radius: 50%; animation: spin 0.8s linear infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <!-- Sidebar -->
    <aside class="sidebar">
        <div class="logo" onclick="goHome()" style="cursor:pointer;">
            <svg viewBox="0 0 100 100" fill="none" xmlns="http://www.w3.org/2000/svg">
                <ellipse cx="50" cy="55" rx="28" ry="24" fill="#8b5cf6"/>
                <ellipse cx="50" cy="55" rx="28" ry="24" fill="url(#stripes)"/>
                <ellipse cx="50" cy="32" rx="18" ry="15" fill="#a78bfa"/>
                <circle cx="42" cy="30" r="4" fill="#1f1f1f"/>
                <circle cx="58" cy="30" r="4" fill="#1f1f1f"/>
                <ellipse cx="28" cy="38" rx="14" ry="7" fill="rgba(255,255,255,0.25)" transform="rotate(-25 28 38)"/>
                <ellipse cx="72" cy="38" rx="14" ry="7" fill="rgba(255,255,255,0.25)" transform="rotate(25 72 38)"/>
                <path d="M44 18 Q50 6 56 18" stroke="#1f1f1f" stroke-width="3" fill="none" stroke-linecap="round"/>
                <circle cx="44" cy="16" r="3" fill="#1f1f1f"/>
                <circle cx="56" cy="16" r="3" fill="#1f1f1f"/>
                <defs><pattern id="stripes" patternUnits="userSpaceOnUse" width="100" height="14"><rect width="100" height="7" fill="#1f1f1f"/></pattern></defs>
            </svg>
        </div>
        <nav class="nav">
            <a class="nav-item active" data-page="home" onclick="navigateTo('home')">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 12l2-2m0 0l7-7 7 7M5 10v10a1 1 0 001 1h3m10-11l2 2m-2-2v10a1 1 0 01-1 1h-3m-6 0a1 1 0 001-1v-4a1 1 0 011-1h2a1 1 0 011 1v4a1 1 0 001 1m-6 0h6"/></svg>
                <span>Home</span>
            </a>
            <a class="nav-item" data-page="tasks" onclick="navigateTo('tasks')">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-6 9l2 2 4-4"/></svg>
                <span>Tasks</span>
            </a>
            <a class="nav-item" data-page="wallets" onclick="navigateTo('wallets')">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"/></svg>
                <span>Wallets</span>
            </a>
            <a class="nav-item" data-page="nfts" onclick="navigateTo('nfts')">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16l4.586-4.586a2 2 0 012.828 0L16 16m-2-2l1.586-1.586a2 2 0 012.828 0L20 14m-6-6h.01M6 20h12a2 2 0 002-2V6a2 2 0 00-2-2H6a2 2 0 00-2 2v12a2 2 0 002 2z"/></svg>
                <span>NFTs</span>
            </a>
            <a class="nav-item" data-page="rpcs" onclick="navigateTo('rpcs')">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.828 10.172a4 4 0 00-5.656 0l-4 4a4 4 0 105.656 5.656l1.102-1.101m-.758-4.899a4 4 0 005.656 0l4-4a4 4 0 00-5.656-5.656l-1.1 1.1"/></svg>
                <span>RPCs</span>
            </a>
            <a class="nav-item" data-page="settings" onclick="navigateTo('settings')">
                <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/></svg>
                <span>Settings</span>
            </a>
        </nav>
    </aside>

    <!-- Main -->
    <main class="main">
        <header class="header">
            <h1 class="header-title" id="pageTitle">Home</h1>
            <div class="header-right">
                <select class="network-select" id="networkSelect">
                    <option value="1">Ethereum</option>
                    <option value="8453">Base</option>
                    <option value="84532">Base Sepolia</option>
                    <option value="42161">Arbitrum</option>
                    <option value="10">Optimism</option>
                    <option value="137">Polygon</option>
                </select>
                <div id="walletArea">
                    <button class="connect-btn" onclick="connectWallet()">Connect</button>
                </div>
            </div>
        </header>

        <div class="notification" id="notification"><span id="notifMsg"></span></div>

        <!-- HOME PAGE -->
        <div class="page active" id="page-home">
            <div class="stats-row">
                <div class="stat-card">
                    <div class="icon purple">+</div>
                    <div class="info"><div class="label">Task Groups</div><div class="value" id="statGroups">0</div></div>
                </div>
                <div class="stat-card">
                    <div class="icon green">✓</div>
                    <div class="info"><div class="label">Successful Mints</div><div class="value" id="statMinted">0</div></div>
                </div>
                <div class="stat-card">
                    <div class="icon red">✕</div>
                    <div class="info"><div class="label">Failed</div><div class="value" id="statFailed">0</div></div>
                </div>
            </div>

            <div class="card mb-20">
                <div class="card-header">
                    <span class="card-title">Active Task Groups</span>
                    <button class="btn btn-sm" onclick="navigateTo('tasks')">View All</button>
                </div>
                <div class="card-body">
                    <div class="task-groups" id="homeTaskGroups">
                        <div class="text-muted" style="padding:20px;text-align:center;">No task groups yet</div>
                    </div>
                </div>
            </div>

            <div class="card">
                <div class="card-header"><span class="card-title">Activity Log</span></div>
                <table>
                    <thead><tr><th>Time</th><th>Activity</th><th>TX</th></tr></thead>
                    <tbody id="activityTable"><tr><td colspan="3" class="text-muted" style="text-align:center;padding:40px;">No activity yet</td></tr></tbody>
                </table>
            </div>
        </div>

        <!-- TASKS PAGE -->
        <div class="page" id="page-tasks">
            <div class="mb-20">
                <span style="font-size:0.85rem;color:var(--text-muted);">Task Groups (<span id="taskGroupCount">0</span>)</span>
            </div>

            <div class="task-groups" id="taskGroupsContainer">
                <div class="task-group-new" onclick="showCreateGroupModal()">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                    <span style="font-size:0.8rem;">Create New</span>
                </div>
            </div>

            <div id="selectedGroupArea" style="display:none;">
                <div class="flex-between mb-16">
                    <span style="font-size:0.85rem;">Tasks (<span id="taskCount">0</span>)</span>
                    <div class="btn-group">
                        <button class="btn btn-danger btn-sm" onclick="stopAllTasks()">Stop All</button>
                        <button class="btn btn-primary btn-sm" onclick="showCreateTaskModal()">Create +</button>
                    </div>
                </div>
                <div class="task-list" id="taskList"></div>
            </div>
        </div>

        <!-- WALLETS PAGE -->
        <div class="page" id="page-wallets">
            <div class="flex-between mb-16">
                <div class="wallet-groups" id="walletGroupsContainer">
                    <div class="wallet-group-chip active" data-group="all" onclick="selectWalletGroup('all')">
                        All <span class="count" id="walletCountAll">0</span>
                    </div>
                </div>
                <button class="btn" onclick="showCreateWalletGroupModal()">+ Group</button>
            </div>
            <div class="flex-between mb-16">
                <div class="btn-group">
                    <button class="btn" onclick="refreshBalances()">↻ Refresh</button>
                    <button class="btn" onclick="showMultisenderModal()">✈ Multisend</button>
                </div>
                <div class="btn-group">
                    <button class="btn btn-primary" onclick="showGenerateModal()">+ Generate</button>
                    <button class="btn" onclick="showImportModal()">Import</button>
                </div>
            </div>
            <div class="card">
                <table>
                    <thead><tr><th><input type="checkbox" id="selectAllWallets" onchange="toggleSelectAll()"></th><th>#</th><th>Address</th><th>Group</th><th>Balance</th><th>Actions</th></tr></thead>
                    <tbody id="walletsTable"><tr><td colspan="6" class="text-muted" style="text-align:center;padding:40px;">No wallets</td></tr></tbody>
                </table>
            </div>
        </div>

        <!-- NFTs PAGE -->
        <div class="page" id="page-nfts">
            <div class="card">
                <div class="card-header"><span class="card-title">Search NFTs Across Wallets</span></div>
                <div class="card-body">
                    <div style="display:flex;gap:8px;margin-bottom:16px;">
                        <input type="text" id="nftSearchContract" placeholder="Contract address" style="flex:1;">
                        <button class="btn btn-primary" onclick="searchNFTs()">Search</button>
                    </div>
                </div>
                <table>
                    <thead><tr><th>Token ID</th><th>Owner Wallet</th></tr></thead>
                    <tbody id="nftsTable"><tr><td colspan="2" class="text-muted" style="text-align:center;padding:40px;">Enter contract to search</td></tr></tbody>
                </table>
            </div>
        </div>

        <!-- RPCs PAGE -->
        <div class="page" id="page-rpcs">
            <div class="flex-between mb-16">
                <span style="font-size:0.85rem;color:var(--text-muted);">All Networks</span>
                <div class="btn-group">
                    <button class="btn" onclick="testAllRPCs()">Test All</button>
                    <button class="btn btn-primary" onclick="showAddRPCModal()">+ Add RPC</button>
                </div>
            </div>
            <div class="card">
                <table>
                    <thead><tr><th>Chain</th><th>Name</th><th>URL</th><th>Latency</th><th></th></tr></thead>
                    <tbody id="rpcsTable"></tbody>
                </table>
            </div>
        </div>

        <!-- SETTINGS PAGE -->
        <div class="page" id="page-settings">
            <div class="grid-2">
                <div class="card">
                    <div class="card-header"><span class="card-title">Export Wallets</span></div>
                    <div class="card-body">
                        <button class="btn btn-primary" onclick="exportWallets()" style="width:100%;">Download JSON</button>
                    </div>
                </div>
                <div class="card">
                    <div class="card-header"><span class="card-title">Auto Transfer NFT</span></div>
                    <div class="card-body">
                        <div class="form-group mb-16">
                            <label>Destination Wallet</label>
                            <input type="text" id="autoTransferDest" placeholder="0x...">
                        </div>
                        <div class="toggle" id="autoTransferToggle" onclick="toggleAutoTransfer()">
                            <div class="toggle-track"></div>
                            <span class="toggle-label">Enable Auto Transfer</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </main>

    <!-- MODALS -->

    <!-- Create Task Group Modal -->
    <div class="modal-overlay" id="createGroupModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Create New Task Group</h3>
                <button class="modal-close" onclick="closeModal('createGroupModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group mb-16">
                    <label>Name</label>
                    <input type="text" id="groupName" placeholder="e.g. Bitstars">
                </div>
                <div class="form-group mb-16">
                    <label>Contract Address or Mint Link</label>
                    <input type="text" id="groupContract" placeholder="0x... or https://mint.example.com" oninput="detectContract()">
                </div>
                <div id="contractDetection"></div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="loadTestContract()" style="margin-right:auto;">Load Test Contract</button>
                <button class="btn" onclick="closeModal('createGroupModal')">Cancel</button>
                <button class="btn btn-primary" onclick="createTaskGroup()">Create</button>
            </div>
        </div>
    </div>

    <!-- Create Task Modal -->
    <div class="modal-overlay" id="createTaskModal">
        <div class="modal" style="max-width:600px;">
            <div class="modal-header">
                <h3 id="taskModalTitle">Create Task</h3>
                <button class="modal-close" onclick="closeModal('createTaskModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-row">
                    <div class="form-group required">
                        <label>Wallet Group</label>
                        <select id="taskWalletGroup"></select>
                    </div>
                    <div class="form-group required">
                        <label>Wallets</label>
                        <select id="taskWallets" multiple style="height:60px;"></select>
                    </div>
                    <div class="form-group">
                        <label>Value</label>
                        <div class="input-suffix">
                            <input type="text" id="taskValue" placeholder="0" value="0">
                            <span>ETH</span>
                        </div>
                    </div>
                </div>
                <div class="form-row" style="margin-bottom: 8px;">
                    <div class="form-group" style="grid-column: 1 / -1;">
                        <label>Gas Presets</label>
                        <div class="btn-group" style="margin-top: 4px;">
                            <button type="button" class="btn btn-sm gas-preset" data-preset="normal" onclick="setGasPreset('normal', this)" style="min-height:42px;line-height:1.2;">Normal<br><span style="font-size:0.65rem;opacity:0.8">~$0.50</span></button>
                            <button type="button" class="btn btn-sm gas-preset" data-preset="fast" onclick="setGasPreset('fast', this)" style="min-height:42px;line-height:1.2;">Fast<br><span style="font-size:0.65rem;opacity:0.8">~$1</span></button>
                            <button type="button" class="btn btn-sm gas-preset" data-preset="turbo" onclick="setGasPreset('turbo', this)" style="background: var(--warning); border-color: var(--warning); color: #000; min-height:42px;line-height:1.2;">Turbo<br><span style="font-size:0.65rem;opacity:0.8">~$2</span></button>
                            <button type="button" class="btn btn-sm gas-preset" data-preset="instant" onclick="setGasPreset('instant', this)" style="background: var(--error); border-color: var(--error); color: #fff; min-height:42px;line-height:1.2;">Instant<br><span style="font-size:0.65rem;opacity:0.8">~$4</span></button>
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label>Gas Limit</label>
                        <input type="text" id="taskGasLimit" placeholder="auto" value="auto">
                    </div>
                    <div class="form-group">
                        <label>Max Fee</label>
                        <div class="input-suffix">
                            <input type="text" id="taskMaxFee" placeholder="auto">
                            <span>gwei</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Priority Fee</label>
                        <div class="input-suffix">
                            <input type="text" id="taskPriorityFee" placeholder="auto">
                            <span>gwei</span>
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label>Nonce</label>
                        <input type="text" id="taskNonce" placeholder="auto" value="auto">
                    </div>
                    <div class="form-group required">
                        <label>Chain</label>
                        <select id="taskChain" onchange="updateTaskRPCs()">
                            <option value="1">Ethereum</option>
                            <option value="8453">Base</option>
                            <option value="84532">Base Sepolia</option>
                            <option value="42161">Arbitrum</option>
                            <option value="10">Optimism</option>
                            <option value="137">Polygon</option>
                        </select>
                    </div>
                    <div class="form-group required">
                        <label>RPC</label>
                        <select id="taskRPC"></select>
                    </div>
                </div>
                <div class="form-row">
                    <div class="form-group">
                        <label>Simulate Interval</label>
                        <div class="input-suffix">
                            <input type="number" id="taskSimInterval" placeholder="50" value="50">
                            <span>ms</span>
                        </div>
                    </div>
                    <div class="form-group">
                        <label>Start Time</label>
                        <input type="datetime-local" id="taskStartTime">
                    </div>
                </div>
                <div class="form-group mb-16">
                    <label>Hex Data (optional)</label>
                    <textarea id="taskHex" rows="2" placeholder="0x..." style="font-family:monospace;font-size:0.75rem;"></textarea>
                </div>
                <div class="form-group mb-16">
                    <label>Transfer NFT After Mint</label>
                    <select id="taskTransferAfter">
                        <option value="">Don't transfer</option>
                    </select>
                </div>
                <div style="display:flex;align-items:center;gap:20px;margin-bottom:16px;">
                    <div class="toggle" id="simulateToggle" onclick="this.classList.toggle('active')">
                        <div class="toggle-track"></div>
                        <span class="toggle-label">Simulate</span>
                    </div>
                    <div class="btn-group">
                        <button class="btn btn-sm" id="modeFunction" onclick="setTaskMode('function')">Function</button>
                        <button class="btn btn-sm" id="modeHex" onclick="setTaskMode('hex')">Hex</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-danger" onclick="closeModal('createTaskModal')">Cancel</button>
                <button class="btn btn-primary" id="taskModalBtn" onclick="saveTask()">Create</button>
            </div>
        </div>
    </div>

    <!-- Create Wallet Group Modal -->
    <div class="modal-overlay" id="createWalletGroupModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Create Wallet Group</h3>
                <button class="modal-close" onclick="closeModal('createWalletGroupModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label>Group Name</label>
                    <input type="text" id="newWalletGroupName" placeholder="e.g. Minting Wallets">
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('createWalletGroupModal')">Cancel</button>
                <button class="btn btn-primary" onclick="createWalletGroup()">Create</button>
            </div>
        </div>
    </div>

    <!-- Generate Wallets Modal -->
    <div class="modal-overlay" id="generateModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Generate Wallets</h3>
                <button class="modal-close" onclick="closeModal('generateModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group mb-16">
                    <label>Number of Wallets</label>
                    <input type="number" id="genCount" value="10" min="1" max="100">
                </div>
                <div class="form-group">
                    <label>Add to Group</label>
                    <select id="genGroup"></select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('generateModal')">Cancel</button>
                <button class="btn btn-primary" onclick="generateWallets()">Generate</button>
            </div>
        </div>
    </div>

    <!-- Import Wallets Modal -->
    <div class="modal-overlay" id="importModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Import Wallets</h3>
                <button class="modal-close" onclick="closeModal('importModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group mb-16">
                    <label>Private Keys (one per line)</label>
                    <textarea id="importKeys" rows="6" placeholder="0x1234...&#10;0x5678..."></textarea>
                </div>
                <div class="form-group">
                    <label>Add to Group</label>
                    <select id="importGroup"></select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('importModal')">Cancel</button>
                <button class="btn btn-primary" onclick="importWallets()">Import</button>
            </div>
        </div>
    </div>

    <!-- Multisender Modal -->
    <div class="modal-overlay" id="multisenderModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Multisender</h3>
                <button class="modal-close" onclick="closeModal('multisenderModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group mb-16">
                    <label>From Wallet</label>
                    <select id="msFrom"></select>
                </div>
                <div class="form-group mb-16">
                    <label>Amount per Wallet (ETH)</label>
                    <input type="text" id="msAmount" placeholder="0.01">
                </div>
                <div class="form-group">
                    <label>Send to Group</label>
                    <select id="msToGroup"></select>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('multisenderModal')">Cancel</button>
                <button class="btn btn-primary" onclick="executeMultisend()">Send</button>
            </div>
        </div>
    </div>

    <!-- Send Modal -->
    <div class="modal-overlay" id="sendModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Send ETH</h3>
                <button class="modal-close" onclick="closeModal('sendModal')">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group mb-16">
                    <label>From</label>
                    <input type="text" id="sendFrom" readonly>
                </div>
                <div class="form-group mb-16">
                    <label>Balance</label>
                    <input type="text" id="sendBalance" readonly style="color:var(--success);">
                </div>
                <div class="form-group mb-16">
                    <label>To</label>
                    <input type="text" id="sendTo" placeholder="0x...">
                </div>
                <div class="form-group">
                    <label>Amount (ETH)</label>
                    <div style="display:flex;gap:8px;">
                        <input type="text" id="sendAmount" placeholder="0.01" style="flex:1;">
                        <button class="btn" onclick="setSendMax()">Max</button>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('sendModal')">Cancel</button>
                <button class="btn btn-primary" onclick="executeSend()">Send</button>
            </div>
        </div>
    </div>

    <!-- Balance Check Modal -->
    <div class="modal-overlay" id="balanceCheckModal">
        <div class="modal">
            <div class="modal-header">
                <h3>Insufficient Funds</h3>
                <button class="modal-close" onclick="closeModal('balanceCheckModal')">&times;</button>
            </div>
            <div class="modal-body">
                <p style="margin-bottom:12px;color:var(--warning);">Some wallets don't have enough ETH for this mint:</p>
                <div id="balanceCheckList" style="max-height:200px;overflow-y:auto;margin-bottom:16px;"></div>
                <p style="font-size:0.85rem;color:var(--text-muted);" id="balanceCheckSummary"></p>
            </div>
            <div class="modal-footer">
                <button class="btn" onclick="closeModal('balanceCheckModal')">Cancel</button>
                <button class="btn btn-primary" id="balanceCheckProceed" onclick="proceedWithFundedWallets()">Mint with Funded Only</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIG ====================
        const WHITELIST = [
            '0xE5E39013e66B3cA9C41814f79bA492e88D86004d',
            '0xB4Be85887D68A3dFDd5e9826A5b7744379FD34E4',
        ].map(a => a.toLowerCase());

        // Test contract on Base Sepolia
        const TEST_CONTRACT = {
            address: '0x8F8e87439f5f4d27A1E3bc9F6b4eb6C4B0Ac5aB8',
            name: 'MRZ Test',
            symbol: 'MRZT',
            chain: 84532,
            mintFn: 'mint(uint256)',
            maxPerTx: 5
        };

        const NETWORKS = {
            1: { name: 'Ethereum', symbol: 'ETH', explorer: 'https://etherscan.io' },
            8453: { name: 'Base', symbol: 'ETH', explorer: 'https://basescan.org' },
            84532: { name: 'Base Sepolia', symbol: 'ETH', explorer: 'https://sepolia.basescan.org' },
            42161: { name: 'Arbitrum', symbol: 'ETH', explorer: 'https://arbiscan.io' },
            10: { name: 'Optimism', symbol: 'ETH', explorer: 'https://optimistic.etherscan.io' },
            137: { name: 'Polygon', symbol: 'MATIC', explorer: 'https://polygonscan.com' }
        };

        const DEFAULT_RPCS = [
            { chain: 1, name: 'LlamaRPC', url: 'https://eth.llamarpc.com' },
            { chain: 1, name: 'PublicNode', url: 'https://ethereum.publicnode.com' },
            { chain: 1, name: 'Ankr', url: 'https://rpc.ankr.com/eth' },
            { chain: 8453, name: 'Base Official', url: 'https://mainnet.base.org' },
            { chain: 8453, name: 'PublicNode Base', url: 'https://base.publicnode.com' },
            { chain: 84532, name: 'Base Sepolia', url: 'https://sepolia.base.org' },
            { chain: 42161, name: 'Arbitrum Official', url: 'https://arb1.arbitrum.io/rpc' },
            { chain: 42161, name: 'PublicNode Arb', url: 'https://arbitrum-one.publicnode.com' },
            { chain: 10, name: 'Optimism Official', url: 'https://mainnet.optimism.io' },
            { chain: 137, name: 'Polygon Official', url: 'https://polygon-rpc.com' },
        ];

        // RPC fallback helper - tries multiple RPCs for a chain
        async function getWorkingProvider(chainId, primaryRpc = null) {
            const chainRpcs = rpcs.filter(r => r.chain === chainId);
            if (primaryRpc) {
                chainRpcs.unshift({ url: primaryRpc, chain: chainId, name: 'Primary' });
            }
            for (const rpc of chainRpcs) {
                try {
                    // Use StaticJsonRpcProvider to avoid network detection issues
                    const p = new ethers.providers.StaticJsonRpcProvider(rpc.url, chainId);
                    await p.getBlockNumber(); // Quick connection test
                    return p;
                } catch (e) {
                    console.warn(`RPC ${rpc.name || rpc.url} failed, trying next...`);
                    continue;
                }
            }
            throw new Error(`No working RPC found for chain ${chainId}`);
        }

        // ==================== STATE ====================
        let provider = null;
        let signer = null;
        let userAddress = null;
        let currentNetwork = 1;
        let wallets = [];
        let walletGroups = [{ id: 'default', name: 'Default' }];
        let taskGroups = [];
        let tasks = [];
        let logs = [];
        let stats = { minted: 0, failed: 0 };
        let rpcs = [...DEFAULT_RPCS];
        let selectedTaskGroup = null;
        let selectedWalletGroup = 'all';
        let runningTasks = {};

        // ==================== INIT ====================
        loadData();
        renderAll();

        // Auto-connect
        if (window.ethereum) {
            window.ethereum.request({ method: 'eth_accounts' }).then(acc => {
                if (acc.length > 0) connectWallet();
            });
        }

        // ==================== WALLET CONNECTION ====================
        async function connectWallet() {
            if (!window.ethereum) return alert('Install MetaMask');
            try {
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                provider = new ethers.providers.Web3Provider(window.ethereum);
                signer = provider.getSigner();
                userAddress = await signer.getAddress();

                if (!WHITELIST.includes(userAddress.toLowerCase())) {
                    showNotif('error', 'Wallet not whitelisted');
                    return;
                }

                const bal = await provider.getBalance(userAddress);
                document.getElementById('walletArea').innerHTML = `<div class="wallet-badge"><span class="dot"></span>${userAddress.slice(0,6)}...${userAddress.slice(-4)} | ${parseFloat(ethers.utils.formatEther(bal)).toFixed(4)} ETH</div>`;

                window.ethereum.on('accountsChanged', () => location.reload());
                window.ethereum.on('chainChanged', () => location.reload());
            } catch (err) { console.error(err); }
        }

        document.getElementById('networkSelect').addEventListener('change', (e) => {
            currentNetwork = parseInt(e.target.value);
            renderRPCs();
            populateRPCSelect();
        });

        // ==================== TASK GROUPS ====================
        function showCreateGroupModal() {
            document.getElementById('groupName').value = '';
            document.getElementById('groupContract').value = '';
            document.getElementById('contractDetection').innerHTML = '';
            document.getElementById('createGroupModal').classList.add('show');
        }

        function loadTestContract() {
            document.getElementById('groupName').value = TEST_CONTRACT.name;
            document.getElementById('groupContract').value = TEST_CONTRACT.address;
            const detection = document.getElementById('contractDetection');
            detection.innerHTML = `
                <div class="contract-info">
                    <div class="token-icon">${TEST_CONTRACT.symbol.slice(0,2)}</div>
                    <div>
                        <div class="token-name">${TEST_CONTRACT.name}</div>
                        <div class="token-address">${TEST_CONTRACT.address.slice(0,10)}...${TEST_CONTRACT.address.slice(-8)}</div>
                        <div style="font-size:0.7rem;color:var(--warning);margin-top:4px;">Base Sepolia Testnet</div>
                    </div>
                </div>
            `;
            detection.dataset.address = TEST_CONTRACT.address;
            detection.dataset.name = TEST_CONTRACT.name;
            detection.dataset.symbol = TEST_CONTRACT.symbol;
            // Switch network to Base Sepolia
            document.getElementById('networkSelect').value = '84532';
            currentNetwork = 84532;
            showNotif('success', 'Test contract loaded - Base Sepolia');
        }

        let detectTimeout = null;
        async function detectContract() {
            const input = document.getElementById('groupContract').value.trim();
            const detection = document.getElementById('contractDetection');

            if (!input) { detection.innerHTML = ''; return; }

            clearTimeout(detectTimeout);
            detectTimeout = setTimeout(async () => {
                detection.innerHTML = '<div class="detecting"><div class="spinner"></div>Detecting...</div>';

                let contractAddress = input;

                // Check if it's a URL
                if (input.startsWith('http')) {
                    try {
                        const res = await fetch('/api/extract', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ url: input })
                        });
                        const data = await res.json();
                        if (data.bestGuess) {
                            contractAddress = data.bestGuess;
                        } else {
                            detection.innerHTML = '<span class="text-error">Could not extract contract from URL</span>';
                            return;
                        }
                    } catch (err) {
                        detection.innerHTML = '<span class="text-error">Failed to fetch URL</span>';
                        return;
                    }
                }

                // Validate address
                if (!ethers.utils.isAddress(contractAddress)) {
                    detection.innerHTML = '<span class="text-error">Invalid address</span>';
                    return;
                }

                // Fetch token info
                try {
                    const rpcUrl = rpcs.find(r => r.chain === currentNetwork)?.url || DEFAULT_RPCS[0].url;
                    const p = new ethers.providers.JsonRpcProvider(rpcUrl, currentNetwork);
                    const abi = ['function name() view returns (string)', 'function symbol() view returns (string)'];
                    const contract = new ethers.Contract(contractAddress, abi, p);

                    let name = 'Unknown', symbol = '???';
                    try { name = await contract.name(); } catch {}
                    try { symbol = await contract.symbol(); } catch {}

                    detection.innerHTML = `
                        <div class="contract-info">
                            <div class="token-icon">${symbol.slice(0,2)}</div>
                            <div>
                                <div class="token-name">${name}</div>
                                <div class="token-address">${contractAddress.slice(0,10)}...${contractAddress.slice(-8)}</div>
                            </div>
                        </div>
                    `;
                    detection.dataset.address = contractAddress;
                    detection.dataset.name = name;
                    detection.dataset.symbol = symbol;

                    // Auto-fill name with token name
                    if (!document.getElementById('groupName').value.trim()) {
                        document.getElementById('groupName').value = name !== 'Unknown' ? name : symbol;
                    }
                } catch (err) {
                    detection.innerHTML = `<div class="contract-info"><div class="token-icon">?</div><div><div class="token-name">Contract Found</div><div class="token-address">${contractAddress}</div></div></div>`;
                    detection.dataset.address = contractAddress;
                }
            }, 500);
        }

        function createTaskGroup() {
            const name = document.getElementById('groupName').value.trim();
            const detection = document.getElementById('contractDetection');
            const contract = detection.dataset?.address || document.getElementById('groupContract').value.trim();

            if (!name) return showNotif('error', 'Enter group name');
            if (!contract || !ethers.utils.isAddress(contract)) return showNotif('error', 'Invalid contract');

            const group = {
                id: Date.now().toString(),
                name,
                contract,
                tokenName: detection.dataset?.name || 'Unknown',
                symbol: detection.dataset?.symbol || '???',
                pending: 0,
                success: 0,
                failed: 0
            };

            taskGroups.push(group);
            saveData();
            renderTaskGroups();
            closeModal('createGroupModal');
            showNotif('success', 'Task group created');
        }

        function renderTaskGroups() {
            const container = document.getElementById('taskGroupsContainer');
            const homeContainer = document.getElementById('homeTaskGroups');
            document.getElementById('taskGroupCount').textContent = taskGroups.length;
            document.getElementById('statGroups').textContent = taskGroups.length;

            const groupsHtml = taskGroups.map(g => `
                <div class="task-group ${selectedTaskGroup === g.id ? 'active' : ''}" onclick="selectTaskGroup('${g.id}')">
                    <button class="close" onclick="event.stopPropagation();deleteTaskGroup('${g.id}')">&times;</button>
                    <div class="name"><span class="icon">◆</span> ${g.name}</div>
                    <div class="stats">
                        <span>☰ ${g.pending}</span>
                        <span class="text-success">✓ ${g.success}</span>
                        <span class="text-error">✕ ${g.failed}</span>
                    </div>
                </div>
            `).join('');

            container.innerHTML = groupsHtml + `
                <div class="task-group-new" onclick="showCreateGroupModal()">
                    <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/></svg>
                    <span style="font-size:0.8rem;">Create New</span>
                </div>
            `;

            // Home page task groups (clickable to navigate)
            if (taskGroups.length === 0) {
                homeContainer.innerHTML = '<div class="text-muted" style="padding:20px;text-align:center;">No task groups yet. <a href="#" onclick="navigateTo(\'tasks\');return false;" style="color:var(--accent);">Create one</a></div>';
            } else {
                homeContainer.innerHTML = taskGroups.map(g => `
                    <div class="task-group" onclick="goToTaskGroup('${g.id}')" style="cursor:pointer;">
                        <div class="name"><span class="icon">◆</span> ${g.name}</div>
                        <div class="stats">
                            <span>☰ ${g.pending}</span>
                            <span class="text-success">✓ ${g.success}</span>
                            <span class="text-error">✕ ${g.failed}</span>
                        </div>
                    </div>
                `).join('');
            }
        }

        function goToTaskGroup(id) {
            navigateTo('tasks');
            selectTaskGroup(id);
        }

        function selectTaskGroup(id) {
            selectedTaskGroup = id;
            renderTaskGroups();
            document.getElementById('selectedGroupArea').style.display = 'block';
            renderTasks();
        }

        function deleteTaskGroup(id) {
            if (!confirm('Delete this task group?')) return;
            taskGroups = taskGroups.filter(g => g.id !== id);
            tasks = tasks.filter(t => t.groupId !== id);
            if (selectedTaskGroup === id) selectedTaskGroup = null;
            saveData();
            renderTaskGroups();
            document.getElementById('selectedGroupArea').style.display = selectedTaskGroup ? 'block' : 'none';
        }

        // ==================== TASKS ====================
        var editingTaskId = null;

        function showCreateTaskModal() {
            if (!selectedTaskGroup) return showNotif('error', 'Select a task group first');
            editingTaskId = null;
            document.getElementById('taskModalTitle').textContent = 'Create Task';
            document.getElementById('taskModalBtn').textContent = 'Create';
            document.getElementById('taskValue').value = '0';
            document.getElementById('taskGasLimit').value = 'auto';
            document.getElementById('taskMaxFee').value = '';
            document.getElementById('taskPriorityFee').value = '';
            document.getElementById('taskNonce').value = 'auto';
            document.getElementById('taskSimInterval').value = '50';
            document.getElementById('taskStartTime').value = '';
            document.getElementById('taskHex').value = '';
            document.getElementById('simulateToggle').classList.remove('active');
            document.getElementById('taskChain').value = currentNetwork;
            document.querySelectorAll('.gas-preset').forEach(btn => btn.classList.remove('active'));
            populateWalletGroupSelect();
            updateGasPresets(); // Fetch current gas prices
            populateRPCSelect();
            populateTransferSelect();
            document.getElementById('createTaskModal').classList.add('show');
        }

        function editTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            if (task.status === 'running') return showNotif('error', 'Cannot edit running task');

            editingTaskId = taskId;
            document.getElementById('taskModalTitle').textContent = 'Edit Task';
            document.getElementById('taskModalBtn').textContent = 'Save';

            // Set chain first, then populate RPCs
            document.getElementById('taskChain').value = task.chain || currentNetwork;
            populateWalletGroupSelect();
            populateRPCSelect();
            populateTransferSelect();

            // Fill form with task values
            document.getElementById('taskValue').value = task.value || '0';
            document.getElementById('taskGasLimit').value = task.gasLimit || 'auto';
            document.getElementById('taskMaxFee').value = task.maxFee || '';
            document.getElementById('taskPriorityFee').value = task.priorityFee || '';
            document.getElementById('taskNonce').value = task.nonce || 'auto';
            document.getElementById('taskSimInterval').value = task.simInterval || '50';
            document.getElementById('taskHex').value = task.hex || '';
            document.getElementById('taskRPC').value = task.rpc || '';
            document.getElementById('taskTransferAfter').value = task.transferAfter || '';

            // Set start time
            if (task.startTime) {
                const dt = new Date(task.startTime);
                const local = new Date(dt.getTime() - dt.getTimezoneOffset() * 60000).toISOString().slice(0, 16);
                document.getElementById('taskStartTime').value = local;
            } else {
                document.getElementById('taskStartTime').value = '';
            }

            // Set simulate toggle
            if (task.simulate) {
                document.getElementById('simulateToggle').classList.add('active');
            } else {
                document.getElementById('simulateToggle').classList.remove('active');
            }

            // Select wallets
            setTimeout(() => {
                const walletSelect = document.getElementById('taskWallets');
                Array.from(walletSelect.options).forEach(opt => {
                    opt.selected = task.wallets.includes(parseInt(opt.value));
                });
            }, 50);

            document.getElementById('createTaskModal').classList.add('show');
        }

        function saveTask() {
            if (editingTaskId) {
                updateTask();
            } else {
                createTask();
            }
        }

        function updateTask() {
            const task = tasks.find(t => t.id === editingTaskId);
            if (!task) return;

            const walletIndices = Array.from(document.getElementById('taskWallets').selectedOptions).map(o => parseInt(o.value));
            if (walletIndices.length === 0) return showNotif('error', 'Select wallets');

            // Update task properties
            task.chain = parseInt(document.getElementById('taskChain').value);
            task.wallets = walletIndices;
            task.value = document.getElementById('taskValue').value || '0';
            task.gasLimit = document.getElementById('taskGasLimit').value || 'auto';
            task.maxFee = document.getElementById('taskMaxFee').value || '';
            task.priorityFee = document.getElementById('taskPriorityFee').value || '';
            task.nonce = document.getElementById('taskNonce').value || 'auto';
            task.rpc = document.getElementById('taskRPC').value;
            task.simInterval = parseInt(document.getElementById('taskSimInterval').value) || 50;
            task.startTime = document.getElementById('taskStartTime').value || null;
            task.hex = document.getElementById('taskHex').value.trim() || '';
            task.transferAfter = document.getElementById('taskTransferAfter').value || '';
            task.simulate = document.getElementById('simulateToggle').classList.contains('active');

            // Reset status if it was stopped
            if (task.status === 'stopped') {
                task.status = 'pending';
            }

            saveData();
            renderTasks();
            closeModal('createTaskModal');
            showNotif('success', 'Task updated');

            // Re-schedule if has start time
            if (task.startTime) {
                scheduleTask(task);
            }
        }

        function populateWalletGroupSelect() {
            const select = document.getElementById('taskWalletGroup');
            select.innerHTML = `<option value="all">All Wallets</option>` + walletGroups.map(g => `<option value="${g.id}">${g.name}</option>`).join('');
            select.onchange = () => populateWalletSelect();
            populateWalletSelect();
        }

        function populateWalletSelect() {
            const groupId = document.getElementById('taskWalletGroup').value;
            const select = document.getElementById('taskWallets');
            // Get wallet indices from original array, not filtered array
            const options = wallets.map((w, originalIndex) => {
                if (groupId === 'all' || w.group === groupId) {
                    return `<option value="${originalIndex}" selected>${w.address.slice(0,6)}...${w.address.slice(-4)}</option>`;
                }
                return '';
            }).join('');
            select.innerHTML = options || '<option disabled>No wallets in this group</option>';
        }

        function populateRPCSelect() {
            const chainId = parseInt(document.getElementById('taskChain').value);
            const select = document.getElementById('taskRPC');
            const filtered = rpcs.filter(r => r.chain === chainId);
            select.innerHTML = filtered.map(r => `<option value="${r.url}">${r.name}</option>`).join('');
        }

        function updateTaskRPCs() {
            populateRPCSelect();
            updateGasPresets(); // Update gas prices for new chain
        }

        // Gas presets for different speed tiers
        const GAS_PRESETS = {
            normal: { maxFee: '', priorityFee: '', usd: '~$0.50' },
            fast: { maxFee: '50', priorityFee: '2', usd: '~$1' },
            turbo: { maxFee: '100', priorityFee: '5', usd: '~$2' },
            instant: { maxFee: '200', priorityFee: '10', usd: '~$4' }
        };

        let ethPriceUsd = 2500; // Default, will be updated

        function setGasPreset(preset, btn) {
            const p = GAS_PRESETS[preset];
            if (!p) return;
            document.getElementById('taskMaxFee').value = p.maxFee;
            document.getElementById('taskPriorityFee').value = p.priorityFee;
            // Highlight selected preset
            document.querySelectorAll('.gas-preset').forEach(b => b.classList.remove('active'));
            if (btn) btn.classList.add('active');
        }

        // Fetch ETH price for USD estimates
        async function fetchEthPrice() {
            try {
                const resp = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=ethereum&vs_currencies=usd');
                const data = await resp.json();
                ethPriceUsd = data.ethereum?.usd || 2500;
            } catch (e) {
                console.warn('Could not fetch ETH price:', e);
            }
        }

        // Calculate gas cost in USD (assuming 150k gas for NFT mint)
        function calcGasCostUsd(maxFeeGwei) {
            const gasLimit = 150000; // Typical NFT mint
            const gasCostEth = (maxFeeGwei * gasLimit) / 1e9;
            return gasCostEth * ethPriceUsd;
        }

        // Fetch current gas prices and update presets dynamically
        async function updateGasPresets() {
            try {
                const chainId = parseInt(document.getElementById('taskChain')?.value || '1');
                const rpcUrl = rpcs.find(r => r.chain === chainId)?.url || DEFAULT_RPCS[0].url;
                const provider = new ethers.providers.StaticJsonRpcProvider(rpcUrl, chainId);
                const feeData = await provider.getFeeData();
                const baseGwei = parseFloat(ethers.utils.formatUnits(feeData.maxFeePerGas || feeData.gasPrice, 'gwei'));

                // Fetch ETH price if not recently fetched
                await fetchEthPrice();

                // Update presets based on current network conditions
                const normalGwei = Math.ceil(baseGwei);
                const fastGwei = Math.ceil(baseGwei * 1.2);
                const turboGwei = Math.ceil(baseGwei * 1.5);
                const instantGwei = Math.ceil(baseGwei * 2);

                GAS_PRESETS.normal.maxFee = '';
                GAS_PRESETS.normal.usd = `~$${calcGasCostUsd(normalGwei).toFixed(2)}`;
                GAS_PRESETS.fast.maxFee = fastGwei.toString();
                GAS_PRESETS.fast.priorityFee = '2';
                GAS_PRESETS.fast.usd = `~$${calcGasCostUsd(fastGwei).toFixed(2)}`;
                GAS_PRESETS.turbo.maxFee = turboGwei.toString();
                GAS_PRESETS.turbo.priorityFee = '5';
                GAS_PRESETS.turbo.usd = `~$${calcGasCostUsd(turboGwei).toFixed(2)}`;
                GAS_PRESETS.instant.maxFee = instantGwei.toString();
                GAS_PRESETS.instant.priorityFee = '10';
                GAS_PRESETS.instant.usd = `~$${calcGasCostUsd(instantGwei).toFixed(2)}`;

                // Update button labels with USD estimates
                updateGasPresetButtons();
            } catch (e) {
                console.warn('Could not fetch gas prices:', e);
            }
        }

        function updateGasPresetButtons() {
            const btns = document.querySelectorAll('.gas-preset');
            btns.forEach(btn => {
                const preset = btn.dataset.preset;
                if (preset && GAS_PRESETS[preset]) {
                    const label = preset.charAt(0).toUpperCase() + preset.slice(1);
                    btn.innerHTML = `${label}<br><span style="font-size:0.65rem;opacity:0.8">${GAS_PRESETS[preset].usd}</span>`;
                }
            });
        }

        function populateTransferSelect() {
            const select = document.getElementById('taskTransferAfter');
            select.innerHTML = `<option value="">Don't transfer</option>` + wallets.map((w, i) => `<option value="${i}">${w.address.slice(0,10)}...</option>`).join('');
        }

        function setTaskMode(mode) {
            document.getElementById('modeFunction').classList.toggle('btn-primary', mode === 'function');
            document.getElementById('modeHex').classList.toggle('btn-primary', mode === 'hex');
        }

        // Stored for balance check flow
        let pendingTaskData = null;
        let fundedWalletIndices = [];

        async function createTask() {
            const group = taskGroups.find(g => g.id === selectedTaskGroup);
            if (!group) return;

            const walletIndices = Array.from(document.getElementById('taskWallets').selectedOptions).map(o => parseInt(o.value));
            if (walletIndices.length === 0) return showNotif('error', 'Select wallets');

            const mintValue = parseFloat(document.getElementById('taskValue').value || '0');
            const chainId = parseInt(document.getElementById('taskChain').value);
            const maxFeeGwei = parseFloat(document.getElementById('taskMaxFee').value || '30');
            const gasLimit = parseInt(document.getElementById('taskGasLimit').value) || 150000;
            const estimatedGasEth = (maxFeeGwei * gasLimit) / 1e9;
            const requiredEth = mintValue + estimatedGasEth + 0.001; // Add small buffer

            // Check balances
            const rpcUrl = document.getElementById('taskRPC').value;
            const provider = new ethers.providers.StaticJsonRpcProvider(rpcUrl, chainId);

            const balanceChecks = await Promise.all(walletIndices.map(async (idx) => {
                const w = wallets[idx];
                try {
                    const balance = await provider.getBalance(w.address);
                    const balanceEth = parseFloat(ethers.utils.formatEther(balance));
                    return { idx, address: w.address, balance: balanceEth, required: requiredEth, funded: balanceEth >= requiredEth };
                } catch (e) {
                    return { idx, address: w.address, balance: 0, required: requiredEth, funded: false, error: true };
                }
            }));

            const underfunded = balanceChecks.filter(c => !c.funded);
            const funded = balanceChecks.filter(c => c.funded);

            // Build task data
            const taskData = {
                id: Date.now().toString(),
                groupId: selectedTaskGroup,
                contract: group.contract,
                chain: chainId,
                wallets: walletIndices,
                value: document.getElementById('taskValue').value || '0',
                gasLimit: document.getElementById('taskGasLimit').value || 'auto',
                maxFee: document.getElementById('taskMaxFee').value || '',
                priorityFee: document.getElementById('taskPriorityFee').value || '',
                nonce: document.getElementById('taskNonce').value || 'auto',
                rpc: rpcUrl,
                simInterval: parseInt(document.getElementById('taskSimInterval').value) || 50,
                startTime: document.getElementById('taskStartTime').value || null,
                hex: document.getElementById('taskHex').value.trim() || '',
                transferAfter: document.getElementById('taskTransferAfter').value || '',
                simulate: document.getElementById('simulateToggle').classList.contains('active'),
                status: 'pending',
                results: []
            };

            if (underfunded.length > 0 && funded.length > 0) {
                // Some wallets underfunded - show modal
                pendingTaskData = taskData;
                fundedWalletIndices = funded.map(c => c.idx);

                const list = document.getElementById('balanceCheckList');
                list.innerHTML = underfunded.map(c => `
                    <div style="display:flex;justify-content:space-between;padding:8px;background:var(--bg-tertiary);border-radius:6px;margin-bottom:6px;font-size:0.8rem;">
                        <span style="font-family:monospace;">${c.address.slice(0,8)}...${c.address.slice(-4)}</span>
                        <span style="color:var(--error);">${c.balance.toFixed(4)} ETH (need ${c.required.toFixed(4)})</span>
                    </div>
                `).join('');

                document.getElementById('balanceCheckSummary').textContent = `${funded.length} of ${walletIndices.length} wallets have enough funds.`;
                document.getElementById('balanceCheckProceed').textContent = `Mint with ${funded.length} Funded Wallet${funded.length > 1 ? 's' : ''}`;

                document.getElementById('balanceCheckModal').classList.add('show');
                return;
            } else if (underfunded.length > 0 && funded.length === 0) {
                // All wallets underfunded
                showNotif('error', `No wallets have enough ETH. Need ${requiredEth.toFixed(4)} ETH each.`);
                return;
            }

            // All wallets funded - proceed
            finalizeTask(taskData);
        }

        function proceedWithFundedWallets() {
            if (!pendingTaskData || fundedWalletIndices.length === 0) return;
            pendingTaskData.wallets = fundedWalletIndices;
            finalizeTask(pendingTaskData);
            closeModal('balanceCheckModal');
            pendingTaskData = null;
            fundedWalletIndices = [];
        }

        function finalizeTask(task) {
            const group = taskGroups.find(g => g.id === task.groupId);
            if (!group) return;

            tasks.push(task);
            group.pending++;
            saveData();
            renderTasks();
            closeModal('createTaskModal');
            showNotif('success', 'Task created');

            // Auto-start if no scheduled time
            if (!task.startTime) {
                runTask(task.id);
            } else {
                scheduleTask(task);
            }
        }

        function scheduleTask(task) {
            const startTime = new Date(task.startTime).getTime();
            const now = Date.now();
            if (startTime > now) {
                setTimeout(() => runTask(task.id), startTime - now);
            } else {
                runTask(task.id);
            }
        }

        async function runTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task || task.status === 'running') return;

            const group = taskGroups.find(g => g.id === task.groupId);
            if (!group) return;

            task.status = 'running';
            task.attempts = 0;
            task.successWallets = [];
            group.pending = Math.max(0, group.pending - 1);
            runningTasks[taskId] = true;
            renderTasks();
            renderTaskGroups();

            // Use StaticJsonRpcProvider to avoid network detection issues
            let p;
            try {
                // Try primary RPC first with static provider (no network check)
                p = new ethers.providers.StaticJsonRpcProvider(task.rpc, task.chain);
                await p.getBlockNumber(); // Quick test
            } catch (e) {
                // Fallback to other RPCs for this chain
                try {
                    p = await getWorkingProvider(task.chain, task.rpc);
                } catch (e2) {
                    task.status = 'failed';
                    addLog('error', `RPC failed for chain ${task.chain}: ${e2.message}`);
                    group.failed++;
                    delete runningTasks[taskId];
                    renderTasks();
                    renderTaskGroups();
                    saveData();
                    return;
                }
            }
            let successCount = 0;

            // Default gas limit fallback for NFT mints when estimation fails
            const FALLBACK_GAS_LIMIT = 300000;

            // Extended ABI with common mint function patterns (defined once)
            const mintAbi = [
                'function mint(uint256) payable',
                'function mint() payable',
                'function publicMint(uint256) payable',
                'function publicMint() payable',
                'function safeMint(address,uint256) payable',
                'function claim(uint256) payable',
                'function claim() payable',
                'function mintPublic(uint256) payable',
                'function mintNFT(uint256) payable',
                'function purchase(uint256) payable',
                'function buy(uint256) payable'
            ];

            // SeaDrop contract addresses
            const SEADROP_ADDRESSES = [
                '0x00005EA00Ac477B1030CE78506496e8C2dE24bf5', // SeaDrop 1.0
                '0x0000000000a39bb272e79075ade125fd351887ac'  // OpenSea SeaDrop
            ];
            const seaDropAbi = [
                'function mintPublic(address nftContract, address feeRecipient, address minterIfNotPayer, uint256 quantity) payable'
            ];

            // Cache for detected mint function (reuse across wallets)
            let detectedMintFn = null;
            let detectedMintType = null; // 'direct', 'seadrop', or 'hex'

            // Simulation mode: keep trying until all succeed or stopped (max 1000 attempts)
            const maxAttempts = task.simulate ? 1000 : 1;

            for (let attempt = 0; attempt < maxAttempts && runningTasks[taskId]; attempt++) {
                task.attempts = attempt + 1;
                renderTasks();

                const stillPending = task.wallets.filter(idx => !task.successWallets?.includes(idx));
                if (stillPending.length === 0) break; // All succeeded

                // PRE-FETCH all nonces in parallel before sending TXs
                // This prevents race conditions when multiple wallets query simultaneously
                const nonceMap = {};
                addLog('info', `Fetching nonces for ${stillPending.length} wallets...`);
                await Promise.all(stillPending.map(async (walletIdx) => {
                    const w = wallets[walletIdx];
                    if (!w) return;
                    try {
                        const wallet = new ethers.Wallet(w.pk, p);
                        nonceMap[walletIdx] = await wallet.getTransactionCount('pending');
                    } catch (e) {
                        nonceMap[walletIdx] = null; // Will auto-fetch later
                    }
                }));

                // Fire ALL wallets simultaneously
                const promises = stillPending.map(async (walletIdx) => {
                    const w = wallets[walletIdx];
                    if (!w) return false;

                    try {
                        const wallet = new ethers.Wallet(w.pk, p);
                        const nonce = nonceMap[walletIdx];
                        let tx;

                        // Build base transaction options
                        const value = ethers.utils.parseEther(task.value || '0');
                        const baseOpts = { value };

                        // Use pre-fetched nonce if available
                        if (nonce !== null) baseOpts.nonce = nonce;

                        // Gas settings with fallback
                        if (task.gasLimit && task.gasLimit !== 'auto') {
                            baseOpts.gasLimit = parseInt(task.gasLimit);
                        }
                        if (task.maxFee) baseOpts.maxFeePerGas = ethers.utils.parseUnits(task.maxFee, 'gwei');
                        if (task.priorityFee) baseOpts.maxPriorityFeePerGas = ethers.utils.parseUnits(task.priorityFee, 'gwei');

                        // Helper to send TX with gas estimation fallback
                        const sendWithFallback = async (txCall) => {
                            try {
                                return await txCall();
                            } catch (e) {
                                // If gas estimation failed, retry with fallback gas limit
                                if (e.code === 'UNPREDICTABLE_GAS_LIMIT' || e.message?.includes('gas')) {
                                    const optsWithGas = { ...baseOpts, gasLimit: FALLBACK_GAS_LIMIT };
                                    // Need to rebuild the call with new opts - throw to use fallback path
                                    throw { ...e, needsFallbackGas: true };
                                }
                                throw e;
                            }
                        };

                        if (task.hex) {
                            // Direct hex calldata
                            const txParams = {
                                to: task.contract,
                                data: task.hex,
                                ...baseOpts
                            };
                            if (!txParams.gasLimit) txParams.gasLimit = FALLBACK_GAS_LIMIT;
                            tx = await wallet.sendTransaction(txParams);
                            detectedMintType = 'hex';
                        } else if (detectedMintFn && detectedMintType) {
                            // Reuse previously detected mint function for speed
                            const opts = { ...baseOpts };
                            if (!opts.gasLimit) opts.gasLimit = FALLBACK_GAS_LIMIT;

                            if (detectedMintType === 'seadrop') {
                                const seaDrop = new ethers.Contract(detectedMintFn.address, seaDropAbi, wallet);
                                tx = await seaDrop.mintPublic(task.contract, ethers.constants.AddressZero, ethers.constants.AddressZero, 1, opts);
                            } else {
                                const contract = new ethers.Contract(task.contract, mintAbi, wallet);
                                tx = await contract[detectedMintFn.name](...detectedMintFn.args(wallet, opts));
                            }
                        } else {
                            // First wallet: detect which mint function works
                            const contract = new ethers.Contract(task.contract, mintAbi, wallet);
                            const opts = { ...baseOpts };
                            if (!opts.gasLimit) opts.gasLimit = FALLBACK_GAS_LIMIT;

                            // Define all mint function attempts
                            const mintAttempts = [
                                { name: 'mint(uint256)', args: (w, o) => [1, o], type: 'direct' },
                                { name: 'mint()', args: (w, o) => [o], type: 'direct' },
                                { name: 'publicMint(uint256)', args: (w, o) => [1, o], type: 'direct' },
                                { name: 'publicMint()', args: (w, o) => [o], type: 'direct' },
                                { name: 'claim(uint256)', args: (w, o) => [1, o], type: 'direct' },
                                { name: 'claim()', args: (w, o) => [o], type: 'direct' },
                                { name: 'mintPublic(uint256)', args: (w, o) => [1, o], type: 'direct' },
                                { name: 'mintNFT(uint256)', args: (w, o) => [1, o], type: 'direct' },
                                { name: 'safeMint(address,uint256)', args: (w, o) => [w.address, 1, o], type: 'direct' },
                                { name: 'purchase(uint256)', args: (w, o) => [1, o], type: 'direct' },
                                { name: 'buy(uint256)', args: (w, o) => [1, o], type: 'direct' },
                            ];

                            // Try direct mint functions first
                            let lastError = null;
                            for (const mint of mintAttempts) {
                                try {
                                    tx = await contract[mint.name](...mint.args(wallet, opts));
                                    detectedMintFn = mint;
                                    detectedMintType = 'direct';
                                    addLog('info', `Detected mint function: ${mint.name}`);
                                    break;
                                } catch (e) {
                                    lastError = e;
                                    continue;
                                }
                            }

                            // If no direct function worked, try SeaDrop
                            if (!tx) {
                                for (const seaDropAddr of SEADROP_ADDRESSES) {
                                    try {
                                        const seaDrop = new ethers.Contract(seaDropAddr, seaDropAbi, wallet);
                                        tx = await seaDrop.mintPublic(task.contract, ethers.constants.AddressZero, ethers.constants.AddressZero, 1, opts);
                                        detectedMintFn = { address: seaDropAddr };
                                        detectedMintType = 'seadrop';
                                        addLog('info', `Using SeaDrop at ${seaDropAddr.slice(0,10)}...`);
                                        break;
                                    } catch (e) {
                                        continue;
                                    }
                                }
                            }

                            if (!tx) {
                                const errDetail = lastError?.reason || lastError?.message || 'unknown';
                                throw new Error(`No mint function worked. Last error: ${errDetail}`);
                            }
                        }

                        addLog('pending', `TX sent: ${w.address.slice(0,8)}...`, tx.hash);

                        // Wait for confirmation with timeout
                        try {
                            const receipt = await Promise.race([
                                tx.wait(1), // Wait for 1 confirmation
                                new Promise((_, reject) => setTimeout(() => reject(new Error('TX confirmation timeout')), 60000))
                            ]);

                            if (receipt.status === 1) {
                                addLog('success', `Confirmed: ${w.address.slice(0,8)}...`, tx.hash);
                                task.successWallets = task.successWallets || [];
                                task.successWallets.push(walletIdx);
                                successCount++;
                                stats.minted++;
                                group.success++;
                                updateStats();
                                renderTasks();
                                return true;
                            } else {
                                addLog('error', `TX reverted: ${w.address.slice(0,8)}...`, tx.hash);
                                return false;
                            }
                        } catch (waitErr) {
                            const waitMsg = waitErr.message || 'Unknown';
                            if (waitMsg.includes('not found') || waitMsg.includes('timeout')) {
                                addLog('error', `TX dropped/timeout: ${w.address.slice(0,8)}...`, tx.hash);
                            } else if (waitMsg.includes('reverted') || waitMsg.includes('revert')) {
                                addLog('error', `TX reverted: ${w.address.slice(0,8)} - ${waitMsg.slice(0,30)}`, tx.hash);
                            } else {
                                addLog('error', `TX failed: ${w.address.slice(0,8)} - ${waitMsg.slice(0,30)}`, tx.hash);
                            }
                            return false;
                        }
                    } catch (err) {
                        const errMsg = err.reason || err.message || 'Failed';
                        if (attempt < 3 || attempt % 100 === 0) {
                            addLog('error', `[${attempt + 1}] ${w.address.slice(0,8)}: ${errMsg.slice(0,50)}`);
                        }
                        return false;
                    }
                });

                await Promise.all(promises);

                // Check if we should continue simulating
                if (!task.simulate) break;
                if (!runningTasks[taskId]) break;

                // Wait for simulate interval before next attempt
                if (task.simInterval > 0) {
                    await new Promise(r => setTimeout(r, task.simInterval));
                }
            }

            // Task complete
            delete runningTasks[taskId];
            const finalSuccess = task.successWallets?.length || 0;
            const finalFail = task.wallets.length - finalSuccess;

            task.status = finalSuccess > 0 ? 'success' : 'failed';
            group.failed += finalFail;

            saveData();
            renderTasks();
            renderTaskGroups();
            updateStats();
            showNotif(finalSuccess > 0 ? 'success' : 'error',
                `Task done: ${finalSuccess}/${task.wallets.length} success after ${task.attempts} attempt(s)`);
        }

        function stopTask(taskId) {
            delete runningTasks[taskId];
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.status = 'stopped';
                saveData();
                renderTasks();
                showNotif('success', 'Task stopped');
            }
        }

        function renderTasks() {
            const list = document.getElementById('taskList');
            const groupTasks = tasks.filter(t => t.groupId === selectedTaskGroup);
            document.getElementById('taskCount').textContent = groupTasks.length;

            if (groupTasks.length === 0) {
                list.innerHTML = '<div class="text-muted" style="text-align:center;padding:40px;">No tasks. Create one to start minting.</div>';
                return;
            }

            list.innerHTML = groupTasks.map(t => {
                const successCount = t.successWallets?.length || 0;
                let statusText = t.status;
                let countdown = '';

                if (t.status === 'running') {
                    statusText = `Simulating... (${t.attempts || 0} attempts, ${successCount}/${t.wallets.length} done)`;
                } else if (t.status === 'pending' && t.startTime) {
                    const startMs = new Date(t.startTime).getTime();
                    const now = Date.now();
                    const diff = startMs - now;
                    if (diff > 0) {
                        const hrs = Math.floor(diff / 3600000);
                        const mins = Math.floor((diff % 3600000) / 60000);
                        const secs = Math.floor((diff % 60000) / 1000);
                        countdown = hrs > 0 ? `${hrs}h ${mins}m ${secs}s` : mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
                        statusText = `Starts in: ${countdown}`;
                    } else {
                        statusText = 'Starting...';
                    }
                }

                const canEdit = t.status === 'pending' || t.status === 'stopped';

                return `
                    <div class="task-item" data-task-id="${t.id}">
                        <div class="info">
                            <div class="status ${t.status}"></div>
                            <div>
                                <div style="font-size:0.85rem;">${t.wallets.length} wallet(s) | ${t.value} ETH ${t.simulate ? '| SIM' : ''}</div>
                                <div class="text-muted" style="font-size:0.7rem;">${statusText}</div>
                            </div>
                        </div>
                        <div class="btn-group">
                            ${canEdit ? `<button class="btn btn-sm" onclick="editTask('${t.id}')">Edit</button>` : ''}
                            ${t.status === 'pending' ? `<button class="btn btn-sm btn-primary" onclick="runTask('${t.id}')">Start</button>` : ''}
                            ${t.status === 'running' ? `<button class="btn btn-sm btn-danger" onclick="stopTask('${t.id}')">Stop</button>` : ''}
                            ${t.status !== 'running' ? `<button class="btn btn-sm" onclick="deleteTask('${t.id}')">✕</button>` : ''}
                        </div>
                    </div>
                `;
            }).join('');
        }

        // Update countdown timers every second
        setInterval(() => {
            const hasScheduled = tasks.some(t => t.status === 'pending' && t.startTime);
            if (hasScheduled && selectedTaskGroup) renderTasks();
        }, 1000);

        function deleteTask(id) {
            tasks = tasks.filter(t => t.id !== id);
            saveData();
            renderTasks();
        }

        function stopAllTasks() {
            tasks.forEach(t => { if (t.status === 'running') t.status = 'stopped'; });
            saveData();
            renderTasks();
            showNotif('success', 'All tasks stopped');
        }

        // ==================== WALLET GROUPS ====================
        function showCreateWalletGroupModal() {
            document.getElementById('newWalletGroupName').value = '';
            document.getElementById('createWalletGroupModal').classList.add('show');
        }

        function createWalletGroup() {
            const name = document.getElementById('newWalletGroupName').value.trim();
            if (!name) return showNotif('error', 'Enter group name');

            walletGroups.push({ id: Date.now().toString(), name });
            saveData();
            renderWalletGroups();
            closeModal('createWalletGroupModal');
            showNotif('success', 'Wallet group created');
        }

        function renderWalletGroups() {
            const container = document.getElementById('walletGroupsContainer');
            container.innerHTML = `
                <div class="wallet-group-chip ${selectedWalletGroup === 'all' ? 'active' : ''}" onclick="selectWalletGroup('all')">
                    All <span class="count">${wallets.length}</span>
                </div>
            ` + walletGroups.map(g => {
                const count = wallets.filter(w => w.group === g.id).length;
                return `<div class="wallet-group-chip ${selectedWalletGroup === g.id ? 'active' : ''}" onclick="selectWalletGroup('${g.id}')">${g.name} <span class="count">${count}</span></div>`;
            }).join('');

            document.getElementById('walletCountAll').textContent = wallets.length;
        }

        function selectWalletGroup(id) {
            selectedWalletGroup = id;
            renderWalletGroups();
            renderWallets();
        }

        // ==================== WALLETS ====================
        function showGenerateModal() {
            populateGroupSelects();
            document.getElementById('generateModal').classList.add('show');
        }

        function showImportModal() {
            populateGroupSelects();
            document.getElementById('importModal').classList.add('show');
        }

        function populateGroupSelects() {
            const html = `<option value="default">Default</option>` + walletGroups.filter(g => g.id !== 'default').map(g => `<option value="${g.id}">${g.name}</option>`).join('');
            document.getElementById('genGroup').innerHTML = html;
            document.getElementById('importGroup').innerHTML = html;
        }

        function generateWallets() {
            const count = parseInt(document.getElementById('genCount').value) || 10;
            const group = document.getElementById('genGroup').value;

            for (let i = 0; i < count; i++) {
                const w = ethers.Wallet.createRandom();
                wallets.push({ address: w.address, pk: w.privateKey, balance: '0', group });
            }

            closeModal('generateModal');
            saveData();
            renderWallets();
            renderWalletGroups();
            showNotif('success', `Generated ${count} wallets`);
        }

        function quickGenerateWallets(count) {
            for (let i = 0; i < count; i++) {
                const w = ethers.Wallet.createRandom();
                wallets.push({ address: w.address, pk: w.privateKey, balance: '0', group: 'default' });
            }
            saveData();
            renderWallets();
            renderWalletGroups();
            showNotif('success', `Generated ${count} wallets. Fund them to mint!`);
        }

        function importWallets() {
            const input = document.getElementById('importKeys').value.trim();
            const group = document.getElementById('importGroup').value;
            if (!input) return;

            const lines = input.split('\n').map(l => l.trim()).filter(l => l);
            let imported = 0;

            for (const line of lines) {
                let pk = line.startsWith('0x') ? line : '0x' + line;
                try {
                    const w = new ethers.Wallet(pk);
                    if (!wallets.find(x => x.address.toLowerCase() === w.address.toLowerCase())) {
                        wallets.push({ address: w.address, pk: w.privateKey, balance: '0', group });
                        imported++;
                    }
                } catch {}
            }

            document.getElementById('importKeys').value = '';
            closeModal('importModal');
            saveData();
            renderWallets();
            renderWalletGroups();
            showNotif('success', `Imported ${imported} wallets`);
        }

        async function refreshBalances() {
            if (wallets.length === 0) return showNotif('error', 'No wallets');
            showNotif('pending', `Refreshing ${wallets.length} wallets...`);
            const rpcUrl = rpcs.find(r => r.chain === currentNetwork)?.url || DEFAULT_RPCS[0].url;
            const p = new ethers.providers.JsonRpcProvider(rpcUrl, currentNetwork);

            // Fetch all balances in parallel for speed
            const promises = wallets.map(async (w) => {
                try {
                    const bal = await p.getBalance(w.address);
                    w.balance = ethers.utils.formatEther(bal);
                } catch { w.balance = '0'; }
            });

            await Promise.all(promises);
            saveData();
            renderWallets();
            renderWalletGroups();
            showNotif('success', 'Balances updated');
        }

        function renderWallets() {
            const tbody = document.getElementById('walletsTable');
            const filtered = selectedWalletGroup === 'all' ? wallets : wallets.filter(w => w.group === selectedWalletGroup);

            if (filtered.length === 0) {
                tbody.innerHTML = '<tr><td colspan="6" class="text-muted" style="text-align:center;padding:40px;">No wallets</td></tr>';
                return;
            }

            tbody.innerHTML = filtered.map((w, i) => {
                const realIdx = wallets.indexOf(w);
                const groupName = walletGroups.find(g => g.id === w.group)?.name || 'Default';
                return `
                    <tr>
                        <td><input type="checkbox" data-index="${realIdx}"></td>
                        <td>${realIdx + 1}</td>
                        <td class="mono" style="font-size:0.75rem;">${w.address.slice(0,10)}...${w.address.slice(-6)} <a href="${NETWORKS[currentNetwork].explorer}/address/${w.address}" target="_blank" class="table-link">↗</a></td>
                        <td><select class="btn-sm" style="padding:2px 6px;" onchange="changeWalletGroup(${realIdx}, this.value)">
                            <option value="default" ${w.group === 'default' ? 'selected' : ''}>Default</option>
                            ${walletGroups.filter(g => g.id !== 'default').map(g => `<option value="${g.id}" ${w.group === g.id ? 'selected' : ''}>${g.name}</option>`).join('')}
                        </select></td>
                        <td class="text-success">${w.balance && !isNaN(parseFloat(w.balance)) ? parseFloat(w.balance).toFixed(4) : '—'}</td>
                        <td>
                            <button class="btn btn-sm" onclick="showSendModal(${realIdx})">Send</button>
                            <button class="btn btn-sm" onclick="copyPK(${realIdx})">Key</button>
                            <button class="btn btn-sm" onclick="removeWallet(${realIdx})">✕</button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function changeWalletGroup(idx, groupId) {
            wallets[idx].group = groupId;
            saveData();
            renderWalletGroups();
        }

        function copyPK(i) {
            navigator.clipboard.writeText(wallets[i].pk);
            showNotif('success', 'Private key copied');
        }

        function removeWallet(i) {
            if (confirm('Remove wallet?')) {
                wallets.splice(i, 1);
                saveData();
                renderWallets();
                renderWalletGroups();
            }
        }

        function toggleSelectAll() {
            const checked = document.getElementById('selectAllWallets').checked;
            document.querySelectorAll('#walletsTable input[type="checkbox"]').forEach(cb => cb.checked = checked);
        }

        async function showSendModal(i) {
            document.getElementById('sendFrom').value = wallets[i].address;
            document.getElementById('sendTo').value = '';
            document.getElementById('sendAmount').value = '';
            document.getElementById('sendBalance').value = 'Loading...';
            document.getElementById('sendModal').classList.add('show');
            document.getElementById('sendModal').dataset.index = i;

            // Fetch current balance
            try {
                const rpcUrl = rpcs.find(r => r.chain === currentNetwork)?.url || DEFAULT_RPCS[0].url;
                const p = new ethers.providers.JsonRpcProvider(rpcUrl, currentNetwork);
                const bal = await p.getBalance(wallets[i].address);
                const balEth = ethers.utils.formatEther(bal);
                wallets[i].balance = balEth;
                document.getElementById('sendBalance').value = balEth + ' ETH';
                document.getElementById('sendModal').dataset.balanceWei = bal.toString();
            } catch (err) {
                document.getElementById('sendBalance').value = 'Error fetching';
            }
        }

        async function setSendMax() {
            const i = parseInt(document.getElementById('sendModal').dataset.index);
            const balWei = document.getElementById('sendModal').dataset.balanceWei;
            if (!balWei) return showNotif('error', 'Balance not loaded');

            try {
                const rpcUrl = rpcs.find(r => r.chain === currentNetwork)?.url || DEFAULT_RPCS[0].url;
                const p = new ethers.providers.JsonRpcProvider(rpcUrl, currentNetwork);

                // Estimate gas for a simple transfer
                const gasPrice = await p.getGasPrice();
                const gasLimit = 21000; // Standard ETH transfer
                const gasCost = gasPrice.mul(gasLimit);

                const balance = ethers.BigNumber.from(balWei);
                const maxSend = balance.sub(gasCost);

                if (maxSend.lte(0)) {
                    showNotif('error', 'Insufficient balance for gas');
                    return;
                }

                document.getElementById('sendAmount').value = ethers.utils.formatEther(maxSend);
            } catch (err) {
                showNotif('error', 'Could not calculate max');
            }
        }

        async function executeSend() {
            const i = parseInt(document.getElementById('sendModal').dataset.index);
            const to = document.getElementById('sendTo').value.trim();
            const amount = document.getElementById('sendAmount').value.trim();

            if (!to || !amount) return showNotif('error', 'Fill all fields');

            try {
                const rpcUrl = rpcs.find(r => r.chain === currentNetwork)?.url || DEFAULT_RPCS[0].url;
                const p = new ethers.providers.JsonRpcProvider(rpcUrl, currentNetwork);
                const wallet = new ethers.Wallet(wallets[i].pk, p);

                showNotif('pending', 'Sending...');
                const tx = await wallet.sendTransaction({ to, value: ethers.utils.parseEther(amount) });
                await tx.wait();

                showNotif('success', 'Sent!');
                closeModal('sendModal');
                refreshBalances();
            } catch (err) {
                showNotif('error', err.message.slice(0, 50));
            }
        }

        function showMultisenderModal() {
            const select = document.getElementById('msFrom');
            select.innerHTML = `<option value="connected">Connected Wallet</option>` + wallets.map((w, i) => `<option value="${i}">${w.address.slice(0,10)}...</option>`).join('');

            const toGroup = document.getElementById('msToGroup');
            toGroup.innerHTML = `<option value="all">All Wallets</option>` + walletGroups.map(g => `<option value="${g.id}">${g.name}</option>`).join('');

            document.getElementById('multisenderModal').classList.add('show');
        }

        async function executeMultisend() {
            const fromVal = document.getElementById('msFrom').value;
            const amount = document.getElementById('msAmount').value.trim();
            const toGroup = document.getElementById('msToGroup').value;

            if (!amount) return showNotif('error', 'Enter amount');

            const targetWallets = toGroup === 'all' ? wallets : wallets.filter(w => w.group === toGroup);
            if (targetWallets.length === 0) return showNotif('error', 'No target wallets');

            // Disperse.app contract - deployed on most EVM chains
            const DISPERSE_ADDRESS = '0xD152f549545093347A162Dce210e7293f1452150';
            const DISPERSE_ABI = ['function disperseEther(address[] recipients, uint256[] values) external payable'];

            let sendSigner;
            if (fromVal === 'connected') {
                if (!signer) return showNotif('error', 'Connect wallet first');
                sendSigner = signer;
            } else {
                const rpcUrl = rpcs.find(r => r.chain === currentNetwork)?.url || DEFAULT_RPCS[0].url;
                const p = new ethers.providers.JsonRpcProvider(rpcUrl, currentNetwork);
                sendSigner = new ethers.Wallet(wallets[parseInt(fromVal)].pk, p);
            }

            const recipients = targetWallets.map(w => w.address);
            const amountWei = ethers.utils.parseEther(amount);
            const values = recipients.map(() => amountWei);
            const totalValue = amountWei.mul(recipients.length);

            showNotif('pending', `Sending ${amount} ETH to ${recipients.length} wallets in 1 tx...`);

            try {
                const disperse = new ethers.Contract(DISPERSE_ADDRESS, DISPERSE_ABI, sendSigner);
                const tx = await disperse.disperseEther(recipients, values, { value: totalValue });
                addLog('pending', `Multisend TX: ${recipients.length} wallets`, tx.hash);
                await tx.wait();
                addLog('success', `Multisend done: ${recipients.length} wallets`, tx.hash);
                closeModal('multisenderModal');
                showNotif('success', `Sent ${amount} ETH to ${recipients.length} wallets!`);
                refreshBalances();
            } catch (err) {
                const errMsg = err.reason || err.message || 'Failed';
                showNotif('error', errMsg.slice(0, 60));
                addLog('error', `Multisend failed: ${errMsg.slice(0, 40)}`);
            }
        }

        function exportWallets() {
            if (wallets.length === 0) return showNotif('error', 'No wallets');
            const data = wallets.map(w => ({ address: w.address, privateKey: w.pk, group: w.group }));
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'mrzbot-wallets.json'; a.click();
        }

        // ==================== NFT SEARCH ====================
        async function searchNFTs() {
            const contract = document.getElementById('nftSearchContract').value.trim();
            if (!contract) return showNotif('error', 'Enter contract');
            if (wallets.length === 0) return showNotif('error', 'No wallets');

            showNotif('pending', 'Searching...');
            const tbody = document.getElementById('nftsTable');
            tbody.innerHTML = '<tr><td colspan="2" class="text-muted" style="text-align:center;padding:20px;">Searching...</td></tr>';

            const rpcUrl = rpcs.find(r => r.chain === currentNetwork)?.url || DEFAULT_RPCS[0].url;
            const p = new ethers.providers.JsonRpcProvider(rpcUrl, currentNetwork);
            const abi = ['function balanceOf(address) view returns (uint256)', 'function tokenOfOwnerByIndex(address,uint256) view returns (uint256)'];
            const nft = new ethers.Contract(contract, abi, p);

            const results = [];
            for (const w of wallets) {
                try {
                    const bal = await nft.balanceOf(w.address);
                    for (let i = 0; i < bal.toNumber(); i++) {
                        const tokenId = await nft.tokenOfOwnerByIndex(w.address, i);
                        results.push({ tokenId: tokenId.toString(), owner: w.address });
                    }
                } catch {}
            }

            if (results.length === 0) {
                tbody.innerHTML = '<tr><td colspan="2" class="text-muted" style="text-align:center;padding:40px;">No NFTs found</td></tr>';
            } else {
                tbody.innerHTML = results.map(r => `<tr><td>#${r.tokenId}</td><td class="mono" style="font-size:0.75rem;">${r.owner.slice(0,10)}...${r.owner.slice(-8)}</td></tr>`).join('');
            }
            showNotif('success', `Found ${results.length} NFTs`);
        }

        // ==================== RPCs ====================
        function renderRPCs() {
            const tbody = document.getElementById('rpcsTable');
            tbody.innerHTML = rpcs.map((r, i) => `
                <tr>
                    <td>${NETWORKS[r.chain]?.name || r.chain}</td>
                    <td>${r.name}</td>
                    <td class="mono" style="font-size:0.7rem;">${r.url.slice(0,35)}...</td>
                    <td><span id="ping-${i}">-</span></td>
                    <td><button class="btn btn-sm" onclick="testRPC(${i})">Test</button></td>
                </tr>
            `).join('');
        }

        async function testRPC(i) {
            const r = rpcs[i];
            const start = Date.now();
            try {
                const p = new ethers.providers.JsonRpcProvider(r.url, r.chain);
                await p.getBlockNumber();
                const ping = Date.now() - start;
                const el = document.getElementById('ping-' + i);
                el.textContent = ping + 'ms';
                el.className = ping < 200 ? 'text-success' : ping < 500 ? '' : 'text-error';
            } catch {
                document.getElementById('ping-' + i).textContent = 'Failed';
                document.getElementById('ping-' + i).className = 'text-error';
            }
        }

        async function testAllRPCs() {
            showNotif('pending', 'Testing all RPCs...');
            for (let i = 0; i < rpcs.length; i++) await testRPC(i);
            showNotif('success', 'RPC tests complete');
        }

        function showAddRPCModal() {
            // Simple prompt for now
            const name = prompt('RPC Name:');
            const url = prompt('RPC URL:');
            if (name && url) {
                rpcs.push({ chain: currentNetwork, name, url });
                saveData();
                renderRPCs();
                showNotif('success', 'RPC added');
            }
        }

        // ==================== ACTIVITY LOG ====================
        function addLog(status, msg, hash = null) {
            logs.unshift({ status, msg, hash, time: new Date().toLocaleTimeString() });
            if (logs.length > 100) logs.pop();
            saveData();
            renderLogs();
        }

        function renderLogs() {
            const tbody = document.getElementById('activityTable');
            if (logs.length === 0) {
                tbody.innerHTML = '<tr><td colspan="3" class="text-muted" style="text-align:center;padding:40px;">No activity yet</td></tr>';
                return;
            }
            tbody.innerHTML = logs.slice(0, 20).map(l => `
                <tr>
                    <td>${l.time}</td>
                    <td class="${l.status === 'success' ? 'text-success' : l.status === 'error' ? 'text-error' : ''}">${l.msg}</td>
                    <td>${l.hash ? `<a href="${NETWORKS[currentNetwork].explorer}/tx/${l.hash}" target="_blank" class="table-link">View ↗</a>` : ''}</td>
                </tr>
            `).join('');
        }

        function updateStats() {
            document.getElementById('statMinted').textContent = stats.minted;
            document.getElementById('statFailed').textContent = stats.failed;
        }

        // ==================== UTILS ====================
        function navigateTo(page) {
            document.querySelectorAll('.nav-item').forEach(i => i.classList.remove('active'));
            document.querySelector('[data-page="' + page + '"]').classList.add('active');
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.getElementById('page-' + page).classList.add('active');
            document.getElementById('pageTitle').textContent = page.charAt(0).toUpperCase() + page.slice(1);
        }

        function goHome() { navigateTo('home'); }

        function closeModal(id) { document.getElementById(id).classList.remove('show'); }

        function showNotif(type, msg) {
            const el = document.getElementById('notification');
            el.className = 'notification show ' + type;
            document.getElementById('notifMsg').textContent = msg;
            if (type !== 'pending') setTimeout(() => el.classList.remove('show'), 3000);
        }

        function toggleAutoTransfer() {
            document.getElementById('autoTransferToggle').classList.toggle('active');
        }

        // ==================== PERSISTENCE ====================
        function saveData() {
            localStorage.setItem('mrz_wallets', JSON.stringify(wallets));
            localStorage.setItem('mrz_walletGroups', JSON.stringify(walletGroups));
            localStorage.setItem('mrz_taskGroups', JSON.stringify(taskGroups));
            localStorage.setItem('mrz_tasks', JSON.stringify(tasks));
            localStorage.setItem('mrz_logs', JSON.stringify(logs));
            localStorage.setItem('mrz_stats', JSON.stringify(stats));
            localStorage.setItem('mrz_rpcs', JSON.stringify(rpcs));
        }

        function loadData() {
            try {
                const w = localStorage.getItem('mrz_wallets'); if (w) wallets = JSON.parse(w);
                const wg = localStorage.getItem('mrz_walletGroups'); if (wg) walletGroups = JSON.parse(wg);
                const tg = localStorage.getItem('mrz_taskGroups'); if (tg) taskGroups = JSON.parse(tg);
                const t = localStorage.getItem('mrz_tasks'); if (t) tasks = JSON.parse(t);
                const l = localStorage.getItem('mrz_logs'); if (l) logs = JSON.parse(l);
                const s = localStorage.getItem('mrz_stats'); if (s) stats = JSON.parse(s);
                const r = localStorage.getItem('mrz_rpcs'); if (r) rpcs = JSON.parse(r);
            } catch {}
        }

        function renderAll() {
            renderTaskGroups();
            renderWalletGroups();
            renderWallets();
            renderRPCs();
            renderLogs();
            updateStats();
        }
    </script>
</body>
</html>
